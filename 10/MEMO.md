# 第10章 コンパイラ#1: 構文解析

## やったこと

本書の指示通りに順に進めていった。

段階的に作り、実際にコンパイルしてみて、出力されるxmlを正解のxmlと比較して、バグやエラーを直して…というのを繰り返した

* コンパイル結果のxmlファイルは、本書の指示通りに作ると、同ファイル内にデフォルトで存在する正解のもの（{jackファイル名}.xml）に上書きされてしまうので、とりあえずは{jackファイル名}.myImpl.xmlとして出力するようにした

### 1段階目

* 字句解析器の作成
    
    * ソースコードをトークンに分離すると同時に各トークンの種類を特定し、結果をxmlに出力するプログラム

### 2段階目

* トークン列を順に読み込んで構造を解析し、コンパイルしていきxmlに構造を出力するプログラムの作成

    * ここではまだexpressionは扱わない(正確には、暫定的なコードで代用)

### 3段階目

* トークン列を順に読み込んで構造を解析し、コンパイルしていきxmlに構造を出力するプログラムの作成

    * expressionもコンパイルできる完全なコンパイラを作成

## メモ

* 基本的には、本書の表をもとにしてゴリゴリ実装していく

    * 細かい単位でも（単に１つのkeywordやsymbolをコンパイルする関数など）どんどんモジュール化していって、その組み合わせでより高次なコンパイルの関数を作って…と繰り返すことでサクサク作れた
    
    * とはいっても結構な量のコードを書いた

* termやsubroutineCallをコンパイルする際、次の次のトークンによって判断しなくてはいけないパターンがいくつか存在

    * Identifierが出現した際にそれがクラス名なのかサブルーチン名なのか変数名なのかを判断できないため

    * 字句解析をするときにIdentifierの種類を区別しておけば回避可能ではある（字句解析器としての役割にしていいのか？

* 今回の実装だと、シンタックスエラーが起きたときにそれがコードの何行目かを特定できない

    * 実際にはよりフレンドリーなコンパイラの実装が求められると感じた